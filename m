Return-Path: <linux-block-owner@vger.kernel.org>
X-Original-To: lists+linux-block@lfdr.de
Delivered-To: lists+linux-block@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.lfdr.de (Postfix) with ESMTP id 831F28D5ED
	for <lists+linux-block@lfdr.de>; Wed, 14 Aug 2019 16:28:52 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726121AbfHNO2v (ORCPT <rfc822;lists+linux-block@lfdr.de>);
        Wed, 14 Aug 2019 10:28:51 -0400
Received: from youngberry.canonical.com ([91.189.89.112]:40605 "EHLO
        youngberry.canonical.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1725955AbfHNO2v (ORCPT
        <rfc822;linux-block@vger.kernel.org>);
        Wed, 14 Aug 2019 10:28:51 -0400
Received: from mail-pg1-f200.google.com ([209.85.215.200])
        by youngberry.canonical.com with esmtps (TLS1.0:RSA_AES_128_CBC_SHA1:16)
        (Exim 4.76)
        (envelope-from <gpiccoli@canonical.com>)
        id 1hxuGf-0000ym-IH
        for linux-block@vger.kernel.org; Wed, 14 Aug 2019 14:28:49 +0000
Received: by mail-pg1-f200.google.com with SMTP id h5so68448520pgq.23
        for <linux-block@vger.kernel.org>; Wed, 14 Aug 2019 07:28:49 -0700 (PDT)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:mime-version
         :content-transfer-encoding;
        bh=7uHFaBE8ZhNAyjr5dmWMEqG4zYwwgGR3dmEDnGu54/4=;
        b=dr9FoerrY6+5nF7/Qn8lrEjc7Zx+PdjBpZsKA9pJAG1lYrW1uiDsQxu3vdUZbCHHX0
         DbZh0saLYMgZ+z2kZHu1uOoo5kHz6qXJ2TaMb98L1fV8KRI7KMDMF9ZY658RV0jM34DF
         ja03e8aDfjmrw0Dkak4kDB9/wMKrYuQsyYX8ZNHPrKsEiejdmsmfveYq6yjzdllpidFb
         Ku+RsWuMDsAJuEMR6fWsLjWUY8qPQUI/Mekmvd96m6LIvCUdoDwpwtpYF+oqHScW/qb3
         xGD6CJldz93Y4+KASzSDbuO57T0dZ1kvPcoi22Vf042+/CrJDu1N4IZ5LintQz1CUh/8
         6udA==
X-Gm-Message-State: APjAAAUm23Il2cjiS+k6IGQlXyBeFJUxT6oICmRz3kEodWqg3DOjF1Ii
        CX5jdKBLo0Os3/HaPzT4wrrmS3kiYKYzbMtN/2C43mG/7YgjS4RTpbTwKCWmGKNNm15vXw8YO0C
        v/2trjHuAZ7WltuPW72GcqI/sjZRKOLgE/LnvTgGV
X-Received: by 2002:a17:902:bf09:: with SMTP id bi9mr40468824plb.143.1565792928375;
        Wed, 14 Aug 2019 07:28:48 -0700 (PDT)
X-Google-Smtp-Source: APXvYqxS/FX+5oVpjJcvMW8Dpe9gfyBKv7pQm0TdJYtzcf9R83TKJ912i7FOulvuf+w06xfHv8UnVg==
X-Received: by 2002:a17:902:bf09:: with SMTP id bi9mr40468808plb.143.1565792928194;
        Wed, 14 Aug 2019 07:28:48 -0700 (PDT)
Received: from localhost ([191.13.19.2])
        by smtp.gmail.com with ESMTPSA id v14sm119820825pfm.164.2019.08.14.07.28.46
        (version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
        Wed, 14 Aug 2019 07:28:47 -0700 (PDT)
From:   "Guilherme G. Piccoli" <gpiccoli@canonical.com>
To:     linux-nvme@lists.infradead.org
Cc:     linux-block@vger.kernel.org, gpiccoli@canonical.com,
        kbusch@kernel.org, axboe@fb.com, hch@lst.de, sagi@grimberg.me,
        jay.vosburgh@canonical.com
Subject: [PATCH] nvme: Use first ctrl->instance id as subsystem id
Date:   Wed, 14 Aug 2019 11:28:36 -0300
Message-Id: <20190814142836.2322-1-gpiccoli@canonical.com>
X-Mailer: git-send-email 2.22.0
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Sender: linux-block-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-block.vger.kernel.org>
X-Mailing-List: linux-block@vger.kernel.org

Since after the introduction of NVMe multipath, we have a struct to
track subsystems, and more important, we have now the nvme block device
name bound to the subsystem id instead of ctrl->instance as before.
This is not a big problem, users can even fallback to the old behavior
using the module parameter "nvme_core.multipath=N" in case they don't
have multipath and wish to have a consistent mapping between the char
device nvmeX and the block device nvmeXnY.

That said, we noticed the nvme subsystem id is generated by its own ID
allocator, and ctrl->instance value has itself an ID allocator too.
The controller instance is generated during the probe, in the function
nvme_init_ctrl(), which always executes before nvme_init_subsystem().
That said, and since according to the spec we have a relation 1:N
between subsystem and controllers (i.e., one subsystem may have more
controllers but not the reciprocal), why not use the ctrl->instance id
as the subsystem id?

This patch does exactly this: removes the ID allocator for subsystems
and use the unique controller instance id as subsystem id. The patch
was tested in multiple scenarios, like:

* multiple controllers (each one tied to its own subsystem);
* 2 controllers in a single subsystem (using emulated nvme controllers
from qemu). In this case, subsystem gets the id of its 1st controller;
* NVMEoF/TCP with this patch in both target and host kernels.

All test cases worked as expected. With this patch, the "coincidence"
of the char device number matches the block device number is forced for
single-controllers subsystems (the most usual scenario), even without
disabling multipath. It's useful for scenarios with some multipath'ed
controllers and some solo controllers.

Signed-off-by: Guilherme G. Piccoli <gpiccoli@canonical.com>
---
 drivers/nvme/host/core.c | 11 ++---------
 1 file changed, 2 insertions(+), 9 deletions(-)

diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index cca270836892..60631e856b41 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -81,7 +81,6 @@ EXPORT_SYMBOL_GPL(nvme_reset_wq);
 struct workqueue_struct *nvme_delete_wq;
 EXPORT_SYMBOL_GPL(nvme_delete_wq);
 
-static DEFINE_IDA(nvme_subsystems_ida);
 static LIST_HEAD(nvme_subsystems);
 static DEFINE_MUTEX(nvme_subsystems_lock);
 
@@ -2316,7 +2315,6 @@ static void nvme_release_subsystem(struct device *dev)
 	struct nvme_subsystem *subsys =
 		container_of(dev, struct nvme_subsystem, dev);
 
-	ida_simple_remove(&nvme_subsystems_ida, subsys->instance);
 	kfree(subsys);
 }
 
@@ -2445,12 +2443,8 @@ static int nvme_init_subsystem(struct nvme_ctrl *ctrl, struct nvme_id_ctrl *id)
 	subsys = kzalloc(sizeof(*subsys), GFP_KERNEL);
 	if (!subsys)
 		return -ENOMEM;
-	ret = ida_simple_get(&nvme_subsystems_ida, 0, 0, GFP_KERNEL);
-	if (ret < 0) {
-		kfree(subsys);
-		return ret;
-	}
-	subsys->instance = ret;
+
+	subsys->instance = ctrl->instance;
 	mutex_init(&subsys->lock);
 	kref_init(&subsys->ref);
 	INIT_LIST_HEAD(&subsys->ctrls);
@@ -4051,7 +4045,6 @@ static int __init nvme_core_init(void)
 
 static void __exit nvme_core_exit(void)
 {
-	ida_destroy(&nvme_subsystems_ida);
 	class_destroy(nvme_subsys_class);
 	class_destroy(nvme_class);
 	unregister_chrdev_region(nvme_chr_devt, NVME_MINORS);
-- 
2.22.0

